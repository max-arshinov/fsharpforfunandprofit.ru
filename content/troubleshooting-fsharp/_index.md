---
layout: page
title: "Исправление ошибок F#"
description: "Почему мой код не компилируется?"
nav: troubleshooting-fsharp
hasComments: 1
date: 2020-01-01
---

Говорят, что "если код компилируется, то он правильный", но иногда невероятно сложно заставить код даже компилироваться!
Так что эта страница написана, чтобы помочь вам справляться с ошибками в вашем F# коде.

Сначала я дам несколько универсальных советов по исправлению и расскажу о самых частых ошибках, которые совершают новички.
Затем я подробно остановлюсь на сообщениях об ошибках, и покажу, из-за чего они возникают, и как их исправить.

[(Ошибки по номерам)](#ошибки-компилятора-f)

## Общие советы по исправлению ошибок ##

Безусловно, важнейшее, что вы можете сделать — это глубоко разобраться в F#, особенно в базовых концепциях, таких как функции и система типов.
Так что, пожалуйста, прочитайте и перечитайте циклы статей о том, как ["мыслить функционально"](/series/thinking-functionally.html) и ["разбираться в типах F#"](/series/understanding-fsharp-types.html), поиграйтесь с примерами, и освойте основные идеи, прежде чем приступать к серьёзным вещам.

Если у вас есть опыт императивного программирования, например на C#, вы можете принести с собой вредные привычки, такие как поиск и исправление ошибок с помощью отладчика. В F# вы, вероятно, просто не доберётесь до отладки, поскольку компилятор здесь гораздо строже. И, конечно, не существует никакого средства «отлаживать» компилятор, пошагово проверяя его работу. Лучшее средство для отладки ошибок компиляции — это ваша голова, и F# заставляет её включить!

Впрочем, есть несколько ошибок, которые новички совершают неприлично часто, так что я быстро по ним пробегусь.

### Не используйте скобки при вызове функций ###

Правильный разделитель параметров функции в F# — это пробел.
Скобки вам потребуются нечасто, так что не пишите их при вызове функций.

```fsharp
let add x y = x + y
let result = add (1 2)  // неправильно
    // ошибка FS0003: это значение не является функцией и не может быть применено
let result = add 1 2    // правильно
```

### Не путайте кортежи и отдельные параметры функций ###

Запятыми разделяются значения в кортежах.
И кортеж — это один объект, а не два.
Так что вы получите ошибку о неверном типе параметров или о том, что параметров слишком мало.

```fsharp
addTwoParams (1,2)  // пытаемся передать один кортеж вместо двух параметров
   // ошибка FS0001: ожидалось выражение типа int, обнаружен тип 'a * 'b
```

Компилятор трактует `(1,2)` как кортеж, который он пробует передать в "`addTwoParams`".
В результате он жалуется, что первым параметром `addTwoParams` должно быть целое число, а мы пытаемся передать кортеж.

Если вы попытаетесь передать *два* аргумента в функцию, которая ожидает *один* кортеж, вы получите другое неясное сообщение об ошибке.

```fsharp
addTuple 1 2   // пытаемся передать два аргумента вместо одного кортежа
  // ошибка FS0003: это значение не является функцией и не может быть применено
```

### Остерегайтесь неверного числа аргументов ###

Компилятор F# не считает ошибкой слишком малое число аргументов функции (в конце концов, «частичное применение» — одно из важнейших свойств языка), но если вы не понимаете, что происходит, вы получите странные сообщения о несовпадении типов чуть дальше в программе.

Сообщение о слишком большом числе аргументов тоже звучит не очень ясно: "Значение не является функцией".

В этом отношении очень строгим является семейство функций "printf".
Здесь количество аргументов должно быть точным.

Это очень важная тема — крайне важно разобраться в том, как работает частичное применение.
За подробностями обращайтесь к циклу ["мыслить функционально"](/series/thinking-functionally.html).

### Используйте точки с запятой, чтобы разделять значения в списках ###

В тех редких случаях, когда F# нуждается в явном символе-разделителе, скажем, в списках и записях, нужно использовать точку с запятой.

```fsharp
let list1 = [1,2,3]    // неправильно! Это список из ОДНОГО кортежа,
                       // который содержит три значения
let list1 = [1;2;3]    // правильно

type Customer = {Name:string, Address: string}  // неправильно
type Customer = {Name:string; Address: string}  // правильно
```

### Не используйте ! как логическое отрицание и != как проверку на неравенство ###

Восклицательный знак — это не оператор логического отрицания.
Это разыменовывающий оператор для изменяемых ссылок.
Если вы случайно его написали, вы получите такую ошибку:

```fsharp
let y = true
let z = !y
// => ошбика FS0001: ожидается выражение типа 'a ref, обнаружено выражение типа bool
```

Вам нужно использовать ключевое слово "not", точно также, как в SQL или VB.

```fsharp
let y = true
let z = not y       // правильно
```

Чтобы написать «не равно», используйте "<>" — снова, как в SQL или VB.

```fsharp
let z = 1 <> 2      // правильно
```

### Не используйте = для присваивания ###

Оператор присваивания для изменяемых значений выглядит как "`<-`".
Символ равенства может даже не приводить к немедленной ошибке, а просто давать неожиданный результат.

```fsharp
let mutable x = 1
x = x + 1          // вернёт false. x не равно x+1
x <- x + 1         // присвоит x+1 переменной x
```

### Остерегайтесь скрытых символов табуляции ###

Правила отступов очень просты и их легко запомнить.
Но вам нельзя использовать символы табуляции, только пробелы.

```fsharp
let add x y =
{tab}x + y
// => ошибка FS1161: нельзя использовать символы табуляции
```

Убедитесь, что ваш редактор преобразует табуляцию в пробелы.
И проверяйте код, который вы откуда-то вставляете.
Если какой-то код вызывает у вас проблемы, попробуйте удалить все пробелы, а затем добавить их обратно.

### Не путайте обычные значения с функциональными значениями ###

Если вы пытаетесь создать указатель на функцию или делегат, убедитесь, что вы случайно не создали простое значение, которое уже вычислено.

Если вам нужна функция без параметров, которую вы можете вызвать несколько раз, вам надо явно передавать параметр единочного типа `unit`, или определить её как лямбда-функцию.

```fsharp
let reader = new System.IO.StringReader("hello")
let nextLineFn   =  reader.ReadLine()  // неправильно
let nextLineFn() =  reader.ReadLine()  // правильно
let nextLineFn   =  fun() -> reader.ReadLine()  // правильно

let r = new System.Random()
let randomFn   =  r.Next()  // неправильно
let randomFn() =  r.Next()  // правильно
let randomFn   =  fun () -> r.Next()  // правильно
```

Подробно функции без параметров обсуждаются в цикле ["мыслить функционально"](/series/thinking-functionally.html).

### Советы по устранению ошибок вида "недостаточно информации" ###

Компилятор F# (по крайней мере, пока) работает в один проход и читает исходный код слева направо, так что информация о типах, которые описаны дальше в программе, комплилятору недоступна — он её ещё не разобрал.

Часть ошибок может возникнуть именно поэтому, например, ["FS0072: Поиск объекта неопределённого типа"](#FS0072) и ["FS0041: Невозможно определить уникальную перегрузку"](#FS0041). Для каждой из них существуют свои способы исправления, но есть и несколько общих принципов, которые могут помочь, если компилятор жалуется на отсутствие типов или недостаток информации. Вот эти рекомендации:

* Определяйте все элементы программы до того, как их использовать (и убедитесь, что файлы в проекте компилируется в правильном порядке)
* Размещайте объекты, тип которых известен, до объектов, тип которых неизвестен. Например, можно переупорядочить вызовы в конвейере или в подобной цепочке функций так, чтобы в начале шли объекты с известными типами.
* Аннотируйте по мере необходимости. Одна из общих рекомендаций состоит в том, чтобы добавлять аннотации к коду, пока всё не заработает, а потом убирать их, пока вы не достигнете необходимого минимума.

Постарайтесь избегать аннотаций, если это возможно.
Не только потому, что аннотации некрасивы, но и потому, что они повышают хрупкость кода.
Изменять типы намного проще, если ничто в программе не зависит от них явно.

----

## Ошибки компилятора F# ##

----

Вот список основных ошибок, которые, как я думаю, стоит задокументировать. Я не документировал очевидные ошибки — только те, которые кажутся непонятными новичкам.

Я собираюсь обновлять этот список в будущем, и открыт к вашим предложениям по этому поводу.

* [FS0001: Тип 'X' не совпадает с типом 'Y'](#FS0001)
* [FS0003: Значение не является функцией и не может быть применено](#FS0003)
* [FS0008: Приведение типа времени выполнения или сопоставление типа приводит к неопределяемому типу](#FS0008)
* [FS0010: Неожиданный идентификатор в привязке](#FS0010a)
* [FS0010: Не полностью структурированная конструкция](#FS0010b)
* [FS0013: Статическое приведение типа X к типу Y приводит к неопределённому типу](#FS0013)
* [FS0020: Выражение должно иметь тип 'unit'](#FS0020)
* [FS0030: Ограничение на значение](#FS0030)
* [FS0035: Эта конструкция устарела](#FS0035)
* [FS0039: Поле, конструктор или член X не определён](#FS0039)
* [FS0041: Невозможно определить уникальную перегрузку](#FS0041)
* [FS0049: В образцах нельзя использовать идентификаторы переменных в верхнем регистре](#FS0049)
* [FS0072: Поиск объекта неопределённого типа](#FS0072)
* [FS0588: Блок, следующий за оператором 'let', не завершён](#FS0588)

## FS0001: Тип 'X' не совпадает с типом 'Y' {#FS0001}

Возможно, это самая частая ошибка, с которой вы столкнётесь. Она может проявляться в самых разных ситуациях, так что я сгруппировал основные проблемы, добавив примеры и способы исправления.

{{<rawtable>}}
<table class="table table-striped table-bordered table-condensed">
<thead>
  <tr>
	<th>Сообщение об ошибке</th>
	<th>Возможные причины</th>
  </tr>
</thead>
<tbody>
  <tr>
	<td>Тип 'float' не совпадает с типом 'int'</td>
	<td><a href="#FS0001A">A. Нельзя смешивать числа с плавающей точкой и целые числа.</a></td>
  </tr>
  <tr>
	<td>Тип 'int' не поддерживает никаких операторов с именем 'DivideByInt'</td>
	<td><a href="#FS0001A">A. Нельзя смешивать числа с плавающей точкой и целые числа.</a></td>
  </tr>
  <tr>
	<td>Тип 'X' не совместим с любым из типов</td>
	<td><a href="#FS0001B">B. Использование неверного численного типа.</a></td>
  </tr>
  <tr>
	<td>Тип (функциональный тип) не совпадает с типом (простой тип). Замечания: функциональные типы содержат стрелку, например, <code>'a -&gt; 'b</code>.</td>
	<td><a href="#FS0001C">C. Слишком много аргументов при вызове функции.</a></td>
  </tr>
  <tr>
	<td>Ожидалось выражение типа (функциональный тип), обнаружен тип (простой тип)</td>
	<td><a href="#FS0001C">C. Слишком много аргументов при вызове функции.</a></td>
  </tr>
  <tr>
	<td>Ожидалось выражение типа (функция с N параметрами), обнаружен тип (функция с N-1 параметрами)</td>
	<td><a href="#FS0001C">C. Слишком много аргументов при вызове функции.</a></td>
  </tr>
  <tr>
	<td>Ожидалось выражение типа (простой тип), обнаружен тип (функциональный тип)</td>
	<td><a href="#FS0001D">D. Слишком мало аргументов при вызове функции.</a></td>
  </tr>
  <tr>
	<td>Ожидалось выражение типа (тип), обнаружен тип (другой тип)</td>
	<td><a href="#FS0001E">E. Простое несоответствие типов.</a><br>
	<a href="#FS0001F">F. Несогласованные типы в ветвлениях или сопоставлениях.</a><br>
	<a href="#FS0001G">G. Остерегайтесь вывода типов внутри функции.</a><br>
	</td>
  </tr>
  <tr>
	<td>Несовпадение типов. Ожидается (простой тип), обнаружен (тип кортежа). Замечание: типы кортежа содержат звёздочку, например, <code>'a * 'b</code>.</td>
	<td><a href="#FS0001H">H. Запятая вместо пробела или точки с запятой?</a></td>
  </tr>
  <tr>
	<td>Несовпадение типов. Ожидается (тип кортежа), обнаружен (другой тип кортежа). </td>
	<td><a href="#FS0001I">I. Кортежи должны быть одного типа, чтобы их можно было сравнивать.</a></td>
  </tr>
  <tr>
	<td>Ожидалось выражение типа <code>'a ref</code>, обнаружен тип X</td>
	<td><a href="#FS0001J">J. Не используйте ! как оператор отрицания.</a></td>
  </tr>
  <tr>
	<td>Тип (тип) не совпадает с типом (другой тип)</td>
	<td><a href="#FS0001K">K. Приоритет операторов (особенно, функций и конвейеров).</a></td>
  </tr>
  <tr>
  <td>Ожидалось выражение типа (монадический тип), обнаружен тип <code>'b * 'c</code></td>
	<td><a href="#FS0001L">L. Ошибка let! в выражениях вычисления.</a></td>
  </tr>
</tbody>
</table>
{{</rawtable>}}

### A. Нельзя смешивать числа с плавающей точкой и целые числа {#FS0001A} ###

В отличие от C# и других императивных языков, целые и числа с плавающей точкой нельзя смешивать в выражениях. Вы получите ошибку типа, если попытаетесь сделать так:

```fsharp
1 + 2.0  // неправильно
   // => ошибка FS0001: Тип 'float' не совпадает с типом 'int'
```

Чтобы её исправить, сначала приведите целое к типу `float`:

```fsharp
float 1 + 2.0  // правильно
```

Эта проблема может проявляться при вызове библиотечных функций и в других случаях. Например, вы не можете вычислить среднее арифметическое для списка целых чисел с помощью функции "`average`".

```fsharp
[1..10] |> List.average   // неправильно
   // => ошибка FS0001: Тип 'int' не поддерживает никаких операторов с именем 'DivideByInt'
```

Сначала вы должны привести целые числа к типу `float`, как показано ниже:

```fsharp
[1..10] |> List.map float |> List.average  // правильно
[1..10] |> List.averageBy float  // правильно (использует averageBy)
```

### B. Использование неверного численного типа {#FS0001B} ###

Вы получите ошибку несовместимости типов в случае некорректного приведения численного типа.

```fsharp
printfn "hello %i" 1.0  // число должно быть целым, а не с плавающим
  // ошибка FS0001: Тип float не совместим с любым из типов byte, int16, int32...
```

Одно из решений состоит в том, чтобы привести выражение к нужному типу самостоятельно, если это имеет смысл.

```fsharp
printfn "hello %i" (int 1.0)
```

### C. Слишком много аргументов при вызове функции  {#FS0001C} ###


```fsharp
let add x y = x + y
let result = add 1 2 3
// ==> ошибка FS0001: Тип ''a -> 'b' не совместим с типом 'int'
```

Подсказка в сообщении об ошибке.

Чтобы её исправить, удалите один из аргументов!

Похожие ошибки возникают, если передать слишком много аргументов в `printf`.

```fsharp
printfn "hello" 42
// ==> ошибка FS0001: Ожидалось выражение типа 'a -> 'b, обнаружен тип unit

printfn "hello %i" 42 43
// ==> ошибка FS0001: Несовпадение типов. Ожидается a 'a -> 'b -> 'c, обнаружен 'a -> unit

printfn "hello %i %i" 42 43 44
// ==> ошибка FS0001: Несовпадение типов. Ожидается a  'a -> 'b -> 'c -> 'd, обнаружен 'a -> 'b -> unit
```

### D. Слишком мало аргументов при вызове функции {#FS0001D} ###

Если вы не передали в функцию достаточно аргументов, вы получите частично применённую функцию.
Когда позже вы её используете, вы получите ошибку, потому что это функция, а не вычисленное значение.

```fsharp
let reader = new System.IO.StringReader("hello");

let line = reader.ReadLine        // неправильно, но компилятор не жалуется
printfn "The line is %s" line     // ошибка компилятора здесь!
// ==> ошибка FS0001: Ожидалось выражение типа string,
//                    обнаружен тип unit -> string
```

Для некоторых библиотечных функций .NET это особенно характерно. Речь идёт о функциях с единственным параметром типа `unit`, как у `ReadLine` из примера выше.

Чтобы исправить ошибку, надо передать в функцию правильное число параметров.
Проверяйте тип получившегося значения, чтобы убедиться, что он действительно простой.
В примере с `ReadLine` надо передать значение `()` в качестве аргумента.

```fsharp
let line = reader.ReadLine()      // правильно
printfn "The line is %s" line     // ошибки нет
```

### E. Простое несоответствие типов {#FS0001E} ###

Простейший случай, когда вы встречаетесь с неправильным типом — строки формата печати.

```fsharp
printfn "hello %s" 1.0
// => ошибка FS0001: Ожидалось выражение типа string,
//                   обнаружен тип float
```

### F. Несогласованные типы в ветвлениях или сопоставлениях {#FS0001F} ###

В выражениях ветвления и сопоставления все ветки ДОЛЖНЫ иметь один и тот же тип. Если нет, вы получите ошибку.

```fsharp
let f x =
  if x > 1 then "hello"
  else 42
// => ошибка FS0001: Ожидалось выражение типа string,
//                   обнаружен тип int
```

```fsharp
let g x =
  match x with
  | 1 -> "hello"
  | _ -> 42
// => ошибка FS0001: Ожидалось выражение типа string,
//                   обнаружен тип int
```

Очевидно, простой способ исправить эту ошибку — возвращать в каждой ветке значения одного типа.

```fsharp
let f x =
  if x > 1 then "hello"
  else "42"

let g x =
  match x with
  | 1 -> "hello"
  | _ -> "42"
```

Помните, что если ветка "else" опущена, предполагается, что она возвращает `unit`, поэтому "истинная" ветка таже должна возвращать `unit`.

```fsharp
let f x =
  if x > 1 then "hello"
// error FS0001: Ожидалось значение типа unit,
//               обнаружен тип string
```

Если ветви не могут иметь один и тот же тип, создайте новое объединение, которое содержит оба типа.

```fsharp
type StringOrInt = | S of string | I of int  // новое объединение
let f x =
  if x > 1 then S "hello"
  else I 42
```

### G. Остерегайтесь вывода типов внутри функции {#FS0001G} ###

Функция может повлечь за собой неожиданный вывод типа, который распространится по всему коду. В примере ниже безобидная строка формата приводит к тому, что `doSomething` ожидает строку в качестве параметра.

```fsharp
let doSomething x =
   // что-то делаем
   printfn "x is %s" x
   // делаем что-то ещё

doSomething 1
// => ошибка FS0001: Ожидалось выражение типа string,
//                   обнаружен тип int
```

Чтобы исправить эту ошибку проверяйте сигнатуры функций, спускаясь всё ниже, пока не найдёте виновницу.
Также, используйте самые общие возможные типы и избегайте аннотаций, если получится.

### H. Запятая вместо пробела или точки с запятой? {#FS0001H} ###

Если вы новичок в F#, вы можете случайно разделять аргументы функций запятыми вместо пробелов:

```fsharp
// определяем функцию с двумя параметрами
let add x y = x + 1

add(x,y)   // FS0001: Ожидалось выражение типа int,
           // обнаружен тип 'a * 'b
```

Как исправить? Просто не используйте запятые!

```fsharp
add x y    // правильно
```

Одно из мест, где запятые *нужны* — вызов библиотечных функций .NET. Они принимают кортежи
в качестве аргументов, так что здесь запятые уместны. Фактически, эти вызовы выглядят
точно также, как и в C#.


```fsharp
// правильно
System.String.Compare("a","b")

// неправильно
System.String.Compare "a" "b"
```

### I. Кортежи должны быть одного типа, чтобы их можно было сравнивать или сопоставлять {#FS0001I} ###

Кортежи разных типов сравнивать нельзя. Результатом сравнения кортежа типа `int * int` с кортежем типа `int * string` будет ошибка:

```fsharp
let  t1 = (0, 1)
let  t2 = (0, "hello")
t1 = t2
// => ошибка FS0001: Несоответствие типов. Ожидается тип int * int,
//    обнаружен тип int * string
//    Тип 'int' не сопоставим с типом 'string'
```

Размер также должен быть одинаковым:

```fsharp
let  t1 = (0, 1)
let  t2 = (0, 1, "hello")
t1 = t2
// => ошибка FS0001: Несоответствие типов. Ожидается тип int * int,
//    обнаружен тип int * int * string
//    Кортежи имеют различающиеся размеры 2 и 3
```

Вы можете получить похожую ситуацию, привязывая значения с помощью сопоставления с образцом:

```fsharp
let x,y = 1,2,3
// => ошибка FS0001: Несоответствие типов. Ожидается тип 'a * 'b,
//                   обнаружен тип 'a * 'b * 'c
//                   Кортежи имеют различающиеся размеры 2 и 3

let f (x,y) = x + y
let z = (1,"hello")
let result = f z
// => ошибка FS0001: Несоответствие типов. Ожидается тип int * int,
//                   обнаружен тип int * string
//                   Тип 'int' не сопоставим с типом 'string'
```

### J. Не используйте ! как оператор отрицания {#FS0001J} ###

Если вы используете `!` как оператор отрицания, вы получите ошибку соответствия типов, в котором будет встречаться слово "ref".

```fsharp
let y = true
let z = !y     // неправильно
// => ошибка FS0001: Ошидалось выражение типа 'a ref, обнаружен тип bool
```

Чтобы избавиться от ошибки, используйте ключевое слово "not".

```fsharp
let y = true
let z = not y   // правильно
```

### K. Приоритет операторов (особенно, функций и конвейеров) {#FS0001K} ###

Если вы перепутаете приоритет операторов, у вас могут возникнуть ошибки соответствия типов.
В целом, применение функций имеет высший приоритет по сравнению с другими операторами, так что вы получите ошибку в таком коде:

```fsharp
String.length "hello" + "world"
   // => ошибка FS0001:  Тип 'string' не сопоставим с типом 'int'

// что тут действительно происходит
(String.length "hello") + "world"
```

Чтобы избавиться от ошибки, используйте скобки.


```fsharp
String.length ("hello" + "world")  // правильно
```

И наоборот, приоритет конвейерного оператора ниже приоритета других опреаторов.

```fsharp
let result = 42 + [1..10] |> List.sum
 // => => ошибка FS0001: Тип ''a list' не сопоставим с типом 'int'

// что тут действительно происходит
let result = (42 + [1..10]) |> List.sum
```

Снова, чтобы избавиться от ошибки, используйте скобки.

```fsharp
let result = 42 + ([1..10] |> List.sum)
```

### L. Ошибка let! в вычислительных выражениях (монадах) {#FS0001L} ###

Вот простое вычислительное выражение:

```fsharp
type Wrapper<'a> = Wrapped of 'a

type wrapBuilder() =
    member this.Bind (wrapper:Wrapper<'a>) (func:'a->Wrapper<'b>) =
        match wrapper with
        | Wrapped(innerThing) -> func innerThing

    member this.Return innerThing =
        Wrapped(innerThing)

let wrap = new wrapBuilder()
```

Однако, если вы попытаетесь использовать его, вы получите сообщение об ошибке.

```fsharp
wrap {
    let! x1 = Wrapped(1)   // <== ошибка здесь
    let! y1 = Wrapped(2)
    let z1 = x + y
    return z
    }
// error FS0001: Ожидалось выражения типа Wrapper<'a>,
//               обнаружен тип 'b * 'c
```

Причина в том, что "`Bind`" ожидает кортеж `(wrapper,func)`, а не два отдельных параметра.
(Проверьте сигнатуру метода в документации F#).

Чтобы избавиться от ошибки, измените метод так, чтобы он принимал кортеж в качестве (единственного) параметра.

```fsharp
type wrapBuilder() =
    member this.Bind (wrapper:Wrapper<'a>, func:'a->Wrapper<'b>) =
        match wrapper with
        | Wrapped(innerThing) -> func innerThing
```

## FS0003: Значение не является функцией и не может быть применено {#FS0003} ##

Эта ошибка обычно возникает, если в функцию передано слишком много параметров.

```fsharp
let add1 x = x + 1
let x = add1 2 3
// ==>   ошибка FS0003: Значение не является функцией и не может быть применено
```

Она также может возникнуть при перегрузке оператора, когда оператор нельзя использовать в префиксной или инфиксной форме.

```fsharp
let (!!) x y = x + y
(!!) 1 2              // правильно
1 !! 2                // неправильно — !! нельзя использовать в инфиксной форме
// error FS0003: Значение не является функцией и не может быть применено
```

## FS0008: Приведение во время выполнения или сопоставление типа приводит к неопределяемому типу {#FS0008} ##

Вы часто будете видеть это сообщение, пытаясь использовать оператор "`:?`" для сопоставления типа.


```fsharp
let detectType v =
    match v with
        | :? int -> printfn "this is an int"
        | _ -> printfn "something else"
// ошибка FS0008: Приведение типа времени выполнения или сопоставление типа `a с int
// приводит к неопределяемому типу, если опираться на информацию, доступную в данной точке программы.
// Сопоставление некоторых типов во время выполнения невозможно. Нужна дополнительная аннотация типа.
```

Сообщение говорит вам о проблеме: "сопоставление некоторых типов во время выполнения невозможно".

Решение состоит в том, чтобы "упаковать" значение, что позволит обращаться с ним, как с другими ссылочными объектами, в частности, проверить его тип:

```fsharp
let detectTypeBoxed v =
    match box v with      // используем "упакованное значение v"
        | :? int -> printfn "this is an int"
        | _ -> printfn "something else"

// проверяем
detectTypeBoxed 1
detectTypeBoxed 3.14
```

## FS0010: Неожиданный идентификатор в привязке {#FS0010a} ##

Обычно ошибка возникает из-за неправильного выравнивания выражений в блоке.

<!-- В оригинале используется термин "правило офсайда", которое в русском языке не встречается.
Термин ввёл Питер Лендин в статье 1966 года "Следующие 700 языков программирования".

Формулировка: Any non-whitespace token to the left of the first such token on the previous line is taken to be the start of a new declaration.

Правило определяет языки, где блоки кода определяются отсутпами, а не скобками или ключевыми словами, такими как begin и end.

Перевод правила на русский: Любой токен, не состоящий из пробелов, который находится слева от первого такого же токена в предыдущей строке кода, начинает новую декларацию.

Довольно запутанно. Возможно, похоже на определение офсайда в футболе. -->

```fsharp
//3456789
let f =
  let x=1     // новый отступ в столбце 3
   x+1        // ой! не делайте отступ в столбце 4
              // ошибка FS0010: offside line is at column 3
```

Чтобы избавиться от ошибки, выравнивайте код корректно!

Также смотрите [FS0588: Блок, следующий за оператором 'let', не завершён](#FS0588), где описана другая ошибка, вызыванная некорректным выравниванием.

## FS0010: Не полностью структурированная конструкция {#FS0010b} ##

Ошибка "Не полностью структурированная конструкция" обычно означает, что вы пропустили скобки при вызове конструктора.

```fsharp
type Something() =
   let field = ()

let x1 = new Something     // ошибка FS0010
let x2 = new Something()   // правильно
```

Может также возникнуть, если вы забыли заключить оператор в круглые скобки:

```fsharp
// определяем новый оператор
let (|+) a = -a

|+ 1    // ошибка FS0010:
        // Неожиданный инфиксный оператор

(|+) 1  // Со скобками — всё хорошо!
```

Может также возникнуть, если вы забыли записать один из операндов инфиксного оператора:

```fsharp
|| true  // ошибка FS0010: Неожиданный символ '||'
false || true  // Всё хорошо
```

Может также возникнуть, если вы пытаетесь задать пространство имён в F# Interactive.
Интерактивная консоль не понимает пространства имён.

```fsharp
namespace Customer  // FS0010: Не полностью структурированная конструкция

// определяем тип
type Person= {First:string; Last:string}
```

## FS0013: Статическое приведение типа X к типу Y приводит к неопределённому типу {#FS0013} ##

*В оригильано тексте этот раздел отсутствует.*

## FS0020: Выражение должно иметь тип 'unit' {#FS0020} ##

Эта ошибка обычно возникает в двух случаях:

* Выражения, которые не являются последними выражениями в блоке
* Использование неверного оператора присваивания

### FS0020 из-за выражений, которые не являются последними выражениями в блоке ###

Возвращать значение может только последнее выражение в блоке. Все остальные должны возвращать значение типа `unit`. Так что ошибка обычно возникает, когда у вас есть функция там в какой-то из строк, кроме последней.

```fsharp
let something =
  2+2               // => FS0020: Это выражение должно иметь тип 'unit'
  "hello"
```

Простое исправление заключается в вызове функции `ignore`. Однако, спросите себя, почему вы используете функции, а потом игнорируете её результат — возможно, это ошибка.

```fsharp
let something =
  2+2 |> ignore     // правильно
  "hello"
```

Кроме того, эта ошибка возникает, если вы по привычке из C# случайно используете точку с запятой, чтобы разделять выражения:

```fsharp
// неправильно
let result = 2+2; "hello";

// правильно
let result = 2+2 |> ignore; "hello";
```

### FS0020 из-за присваивания ###

Другой вариант этой ошибки возникает, когда вы присваивате значение свойству.

```text
Это выражение должно иметь тип 'unit', но имеет тип 'Y'.
```

В этой ошибке, скорее всего, вы перепутали оператор присваивания "`<-`" для изменяемых значений с оператором сравнения "`=`".

```fsharp
// '=' вместо '<-'
let add() =
    let mutable x = 1
    x = x + 1          // предупреждение FS0020
    printfn "%d" x
```

Чтобы избавиться от ошибки, используйте правильный оператор присваивания.

```fsharp
// исправлено
let add() =
    let mutable x = 1
    x <- x + 1
    printfn "%d" x
```

## FS0030: Ограничение на значение {#FS0030} ##

Эта ошибка связана с автоматическим расширением до обобщённого типа, когда это возможно.

Например, в таком коде:

```fsharp
let id x = x
let compose f g x = g (f x)
let opt = None
```

механизм вывода типов F# проявит смекалку и определит обобщённые типы.

```fsharp
val id : 'a -> 'a
val compose : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c
val opt : 'a option
```

Но в некоторых случаях компилятор F# посчитает код неоднозначным и, хотя кажется, что он правильно угадывает тип, ему нужно, чтобы вы были более конкретными.

```fsharp
let idMap = List.map id             // ошибка FS0030
let blankConcat = String.concat ""  // ошибка FS0030
```

Почти всегда ошибка будет вызвана попыткой определить частично применённую функцию, и почти всегда простейшее исправление заключается в явном добавлении недостающего параметра.

```fsharp
let idMap list = List.map id list             // правильно
let blankConcat list = String.concat "" list  // правильно
```

Больше деталей вы найдёте в статье MSDN, посвящённой ["автоматическому обобщению"](http://msdn.microsoft.com/en-us/library/dd233183%28v=VS.100%29.aspx).

## FS0035: Эта конструкция устарела {#FS0035} ##

> F# syntax has been cleaned up over the last few years, so if you are using examples from an older F# book or webpage, you may run into this.
> See the MSDN documentation for the correct syntax.

Синтаксис F# за последние несколько лет сильно упростился, так что если вы используете примеры из старой книги или старой страницы, посвящённой F#, вы можете столкнуться с такой ошибкой.

```fsharp
let x = 10
let rnd1 = System.Random x         // хорошо
let rnd2 = new System.Random(x)    // хорошо
let rnd3 = new System.Random x     // ошибка FS0035
```

## FS0039: Поле, конструктор или член X не определён {#FS0039} ##

Эта ошибка обычно возникает в одной из четырёх ситуаций.

* Очевидный случай, когда что-то действительно не определено! И убедитесь, что у вас нет опечатки, и вы не перепутали большие и маленькие буквы.
* Интерфейсы
* Рекурсия
* Методы расширения

### FS0039 из-за интерфейсов ###

В F# все интерфейсы должны быть реализованы "явно", в отличие от "неявной" реализации, принятой в C# (см. раздел ["явная реализация интерфейса"](http://msdn.microsoft.com/en-us/library/aa288461%28v=vs.71%29.aspx) где разъясняется отличие).

Суть в том, что когда элемент интерфейса реализован явно, к нему нельзя получить доступ через экземпляр класса, только через экземпляр интерфейса, поэтому вы должны привести объект к типу интерфейса с помощью оператора `:>`.

Вот примера класса, который реализует интерфейс.

```fsharp
type MyResource() =
   interface System.IDisposable with
       member this.Dispose() = printfn "disposed"
```

Этот код не работает:

```fsharp
let x = new MyResource()
x.Dispose()  // ошибка FS0039: Поле, конструктор
             // или член 'Dispose' не определён
```

Чтобы избавиться от ошибки, приведите объект к типу интерфейса, как показано ниже:

```fsharp
// исправлено приведением к System.IDisposable
(x :> System.IDisposable).Dispose()   // правильно

let y =  new MyResource() :> System.IDisposable
y.Dispose()   // правильно
```

### FS0039 из-за рекурсии ###

Вот стандартная реализация чисел Фибоначчи:

```fsharp
let fib i =
   match i with
   | 1 -> 1
   | 2 -> 1
   | n -> fib(n-1) + fib(n-2)
```

К сожалению, этот код компилироваться не будет:

```text
    Ошибка FS0039: Значение или конструктор 'fib' не определён
```

Причина в том, что когда компилятор видит вызов 'fib', он не знает о такой функции, потому что он её ещё не скомпилировал!

Чтобы избавиться от ошибки, используйте ключевое слово "`rec`".

```fsharp
let rec fib i =
   match i with
   | 1 -> 1
   | 2 -> 1
   | n -> fib(n-1) + fib(n-2)
```

Обратите внимание, что оно нужно только при описании функций с помощью "`let`".
Функции-члены в нём не нуждаются, поскольку у них другие правила, касающиеся области видимости.

```fsharp
type FibHelper() =
    member this.fib i =
       match i with
       | 1 -> 1
       | 2 -> 1
       | n -> fib(n-1) + fib(n-2)
```

### FS0039 из-за методов расширения ###

Если вы определили метод расширения, вы не сможете его использовать до тех пор, пока не подключите соответствующий модуль.

Вот простой пример для демонстрации:

```fsharp
module IntExtensions =
    type System.Int32 with
        member this.IsEven = this % 2 = 0
```

Если вы попытаетесь использовать метод расширения, вы получите ошибку FS0039:

```fsharp
let i = 2
let result = i.IsEven
    // FS0039: Поле, конструктор или
    // член 'IsEven' не определён
```

Чтобы избавиться от ошибки, достаточно подключить модуль `IntExtensions`.

```fsharp
open IntExtensions // вводим методы модуля в область видимости
let i = 2
let result = i.IsEven  // исправлено!
```

## FS0041: Невозможно определить уникальную перегрузку {#FS0041} ##

Эта ошибка может возникнуть при вызове библиотечной функции .NET с несколькими перегрузками:

```fsharp
let streamReader filename = new System.IO.StreamReader(filename) // FS0041
```

Есть несколько способов избавиться от ошибки. Во-первых, вы можете использовать аннотации типов:

```fsharp
let streamReader filename = new System.IO.StreamReader(filename:string) // работает
```

Иногда вы можете использовать именованные параметры, чтобы избежать аннотации:

```fsharp
let streamReader filename = new System.IO.StreamReader(path=filename) // работает
```

Или вы можете попытаться создать промежуточные объекты, которые помогают выводу типов и также избавляют нас от аннотаций:

```fsharp
let streamReader filename =
    let fileInfo = System.IO.FileInfo(filename)
    new System.IO.StreamReader(fileInfo.FullName) // работает
```

## FS0049: В образцах нельзя использовать идентификаторы переменных в верхнем регистре {#FS0049} ##

При сопоставлении с образцом не забывайте о тонкой разнице между размеченными объединениями F#, которые содержат только идентификаторы вариантов, и типом `Enum` из .NET.

Размеченные объединения из F#:

```fsharp
type ColorUnion = Red | Yellow
let redUnion = Red

match redUnion with
| Red -> printfn "red"     // без проблем
| _ -> printfn "something else"
```

Но перечисления .NET требуют указания полного имени:

```fsharp
type ColorEnum = Green=0 | Blue=1      // перечисление
let blueEnum = ColorEnum.Blue

match blueEnum with
| Blue -> printfn "blue"     // предупреждение FS0049
| _ -> printfn "something else"
```

Исправленная версия:

```fsharp
match blueEnum with
| ColorEnum.Blue -> printfn "blue"
| _ -> printfn "something else"
```

## FS0072: Поиск объекта неопределённого типа {#FS0072} ##

Ошибка возникает, когда вы пытаетесь обратиться к свойству объекта, чей тип неизвестен.

Рассмотрим следующий пример:

```fsharp
let stringLength x = x.Length // ошибка FS0072
```

Компилятор не знает типа "x" и поэтому не может проверить, что "`Length`" является правильным свойством.

Есть несколько способов избавиться от этой ошибки. Метод "в лоб" — предоставить явную аннотацию типа:

```fsharp
let stringLength (x:string) = x.Length  // правильно
```

В некоторых случаях может помочь разумная реорганизация кода.
Скажем, пример ниже, кажется, должен работать.
Программисту очевидно, что функция `List.map` применяется к списку строк, так почему `x.Length` приводит к ошибке?

```fsharp
List.map (fun x -> x.Length) ["hello"; "world"] // ошибка FS0072
```

Причина заключается в том, что компилятор F# — однопроходный, так что информация о типе, представленная в программе позже, ему не доступна — ведь он о ней ещё не знает.

Да, вы всегда можете добавить явную аннотацию:

```fsharp
List.map (fun x:string -> x.Length) ["hello"; "world"] // работает
```

Но есть и другой, более элегантный способ решения проблемы. Надо реорганизовать код так, чтобы типы шли в начале, и комплиятор узнал про них прежде, чем разбирать следующую конструкцию.

```fsharp
["hello"; "world"] |> List.map (fun x -> x.Length)   // работает
```

Считается хорошей практикой избегать явных аннотаций, так что применяйте этот подход всякий раз, когда получается.

## FS0588: Блок, следующий за оператором 'let', не завершён {#FS0588} ##

Ошибка вызвана неверным выравниваем кода в блоке.

```fsharp
//3456789
let f =
  let x=1    // отступ в 3 пробела
 x+1         // проблема! отступ в 2 пробела!
             // Ошибка FS0588: Блок, следующий за оператором
             // 'let', не завершён
```

Чтобы изабвиться от ошибки, выровняйте код правильно.

Смотрите также раздел [FS0010: Неожиданный идентификатор в привязке](#FS0010a), где рассказано о другой ошибке, вызыванной неправильным выравниваем.
