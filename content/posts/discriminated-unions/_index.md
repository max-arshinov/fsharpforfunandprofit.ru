---
layout: post
title: "Размеченные объединения"
description: "Сложение типов друг с другом"
date: 2012-06-06
nav: fsharp-types
seriesId: "Понимание типов F#"
seriesOrder: 6
categories: [Types]
---

Кортежи и записи — это примеры создания новых типов путем «умножения» существующих типов. В начале цикла я упоминал, что другим способом создания новых типов является «сложение». Что это означает?  

Что ж, представим, что нам нужна функция, которая умеет конвертировать целые числа ИЛИ булевые значения в строку.
Нам бы хотелось быть строгими и не принимать в качестве параметра никаких других типов, например, чисел с плавающей точкой или строк. Вот диаграмма такой функции:

![функция конвертации из целого или булевого значения](./fun_int_union_bool.png)

Как бы мы описали область значений такой функции?

Нам нужен тип, представляющий все возможные целые числа ПЛЮС все возможные булевые значения.

![целое ПЛЮС булевое](./int_union_bool.png)

Другими словами, тип «сумма».

В нашем случае, новый тип — это «сумма» типа «целое» и булевого типа. 

В F# тип «сумма» называется "размеченным объединением" (discriminated union).
У каждого компонента — "варианта объединения" (union case) — должна быть своя метка, которую называют "идентификатором варианта" (case identifier) или "ярлыком" (tag). Метки нужны, чтобы отличать варианты друг от друга. Слово *discriminated* в названии как раз и означает *отличимые* или *различимые*. Метки могут быть любыми идентификаторами, какими захотите, но должны начинаться с заглавной буквы.

Вот как мы можем определить тип, о котором писали выше:

```fsharp
type IntOrBool =
  | I of int
  | B of bool
```

Здесь метки — это "I" и "B". Мы могли бы дать им другие, более осмысленные имена.

Если у нашего типа мало вариантов, мы можем определить его в одну строку:

```fsharp
type IntOrBool = I of int | B of bool
```

Типы компонентов могут быть любыми типами, какие вам нужны: кортежами, записями, другими объединениями и так далее.

```fsharp
type Person = {first:string; last:string}  // определяем тип записи
type IntOrBool = I of int | B of bool

type MixedType =
  | Tup of int * int  // кортеж
  | P of Person       // используем тип записи, определенный выше
  | L of int list     // список целых чисел
  | U of IntOrBool    // используем тип объединения, определенный выше
```

Вы даже можете создавать рекурсивные типы, то есть такие типы, которые ссылаются сами на себя.

Так, например, определяются древовидные структуры.

Ниже мы поговорим о рекурсивных типах подробнее.

### Чем тип суммы отличается от объединений C++ и вариантов VB

На первый взгляд, тип суммы кажется похожим на объединения C++ или варианты Visual Basic, но здесь есть существенное отличие. Объединения в C++ небезопасны с точки зрения типа: данные, хранящиеся внутри, можно извлечь, используя любой ярлык. Размеченные объединения в F# безопасны: данные можно извлечь только одним способом.
О размеченных объединениях полезно думать именно как о сумме двух типов (см. диаграмму), а не как о значениях, которые разделяют одну и ту же память.

## Ключевые пункты в типах объединения

Вот некоторые ключевые моменты, которые нужно знать о типах объединения:

* Можно опускать вертикальную черту у самого первого компонента. Все эти определения эквиваленты, в чём можно убедиться в интерактивном окне:

```fsharp
type IntOrBool = I of int | B of bool     // без начальной черты
type IntOrBool = | I of int | B of bool   // с начальной чертой
type IntOrBool =
   | I of int
   | B of bool      // с начальной чертой на отдельных строках
```

* Названия ярлыков (меток) должны начинаться с заглавной буквы, поэтому такое определение выдаст ошибку:

```fsharp
type IntOrBool = int of int| bool of bool
//  ошибка FS0053: Discriminated union cases
//                 must be uppercase identifiers
```
{{<footnote "*">}}
Мы не переводим текст сообщений об ошибках, потому что, во-первых, именно так их выводит компилятор,
а, во-вторых, так их проще гуглить.
{{</footnote>}}

* Другие именованные типы (такие как `Person` или `IntOrBool`) должны быть определены до
  размеченного объединения, их нельзя «встроить» в само определение:

```fsharp
type MixedType =
  | P of  {first:string; last:string}  // ошибка
```

или

```fsharp
type MixedType =
  | U of (I of int | B of bool)  // ошибка
```

*  Метки могут быть любыми идентификаторами, в том числе совпадать с названиями компонентов,
   что поначалу может немного сбивать с толку.
   Например, если бы типы `Int32` и `Boolean` из пространства имен `System` использовались с
   одноимёнными метками, мы получили бы такое, вполне допустимое определение:   

```fsharp
open System
type IntOrBool = Int32 of Int32 | Boolean of Boolean
```

Этот стиль «дублирующего именования» встречается довольно часто, так как он документирует типы компонентов.

{{< book_page_pdf >}}

## Конструирование значений типа объединения

Чтобы создать значение типа объединения, используйте «конструкторы», которые формируются по одному для каждого варианта. По форме конструктор — это функция, чьё имя совпадает с меткой варианта.
В примере с `IntOrBool` вы могли бы написать:

```fsharp
type IntOrBool = I of int | B of bool

let i  = I 99    // используем конструктор "I"
// val i : IntOrBool = I 99

let b  = B true  // используем конструктор "B"
// val b : IntOrBool = B true
```

Результирующее значение выводится вместе с меткой сразу за типом компонента:

```fsharp
val [имя значения] : [тип]     = [метка] [печать типа компонента]
val i              : IntOrBool = I       99
val b              : IntOrBool = B       true
```

Если у конструктора больше одного параметра, вызывайте его также, как и вызывали бы функцию:

```fsharp
type Person = {first:string; last:string}

type MixedType =
  | Tup of int * int
  | P of Person

let myTup  = Tup (2,99)    // используем конструктор "Tup"
// val myTup : MixedType = Tup (2,99)

let myP  = P {first="Al"; last="Jones"} // используем конструктор "P"
// val myP : MixedType = P {first = "Al";last = "Jones";}
```

Конструкторы вариантов — это обычные функции которые вы можете использовать везде, где ожидаются функции.
Например, в `List.map`:

```fsharp
type C = Circle of int | Rectangle of int * int

[1..10]
|> List.map Circle

[1..10]
|> List.zip [21..30]
|> List.map Rectangle
```

### Конфликты именования

Если каждый вариант в программе имеет свою уникальную метку, при вызове конструкторов не возникает никакой неоднозначности.

Но что случится, если у вас есть два типа, у которых есть варианты с одинаковыми метками?

```fsharp
type IntOrBool1 = I of int | B of bool
type IntOrBool2 = I of int | B of bool
```

В такой ситуации общим правилом является использование последнего определения:

```fsharp
let x = I 99                // val x : IntOrBool2 = I 99
```

Но ещё лучше явно указывать тип, как показано ниже:

```fsharp
let x1 = IntOrBool1.I 99    // val x1 : IntOrBool1 = I 99
let x2 = IntOrBool2.B true  // val x2 : IntOrBool2 = B true
```

Если типы приходят из разных модулей, вы можете использовать также и имя модуля:

```fsharp
module Module1 =
  type IntOrBool = I of int | B of bool

module Module2 =
  type IntOrBool = I of int | B of bool

module Module3 =
  let x = Module1.IntOrBool.I 99 // val x : Module1.IntOrBool = I 99
```

### Сопоставление типов объединения

У кортежей и записей сопоставление с образцом выглядит точно также, как и их создание.
Это справедливо и для типов объединения. Правда, здесь у нас возникает сложность, какую из меток мы должны деконструировать, поэтому типы объединения
имеют несколько конструкторов.

Выражение "match" разработано как раз для этого.
Как вы могли бы догадаться, синтаксис сопоставления похож на синтаксис конструирования.

```fsharp
// определение типа объединения
type MixedType =
  | Tup of int * int
  | P of Person

// "деконструирование" типа объединения
let matcher x =
  match x with
  | Tup (x,y) ->
        printfn "Tuple matched with %i %i" x y
  | P {first=f; last=l} ->
        printfn "Person matched with %s %s" f l

let myTup = Tup (2,99)                 // используем конструктор "Tup"
matcher myTup

let myP = P {first="Al"; last="Jones"} // используем конструктор "P"
matcher myP
```

Давайте проанализируем, что здесь происходит:

* Каждая «ветвь» сопоставления — это выражение образца, которое выглядит также, как соответствюущий
  вариант объединения.
* Образец начинается с метки варианта. Остальная часть образца сопоставляется с типом, относящимся
  к данному варианту.
* За образцом следует стрелка "->" и затем код для выполнения.

## Пустые варианты (empty cases)

Метка варианта объединения не обязательно должна иметь какой-то тип.
Все следующие определения допустимы:

```fsharp
type Directory =
  | Root                   // нет необходимости давать имя корню
  | Subdirectory of string // другие папки должны быть именованы

type Result =
  | Success                // нет необходимости в строке для успешного состояния
  | ErrorMessage of string // сообщение об ошибке необходимо
```

Если *все* варианты пусты, у нас получается объединение, похожее на перечисление (enum):

```fsharp
type Size = Small | Medium | Large
type Answer = Yes | No | Maybe
```

Обратите внимание, что здесь объединение всего лишь похоже на перечисление. Это не тип перечисления
из C#, который мы обсудим позже.

Чтобы создать пустой вариант, используйте метку как конструктор без каких-либо параметров:

```fsharp
let myDir1 = Root
let myDir2 = Subdirectory "bin"

let myResult1 = Success
let myResult2 = ErrorMessage "not found"

let mySize1 = Small
let mySize2 = Medium
```

{{< linktarget "single-case" >}}

## Одиночные варианты (single cases)

Иногда полезно создавать типы объединения с одним вариантом.
Это может показаться бесполезным, потому что вы, кажется, не добавляете ничего нового к существующему значению.
Но на самом деле, это очень полезная практика, которая помогает обеспечить типобезопасноть*. 

{{<footnote "*">}}
И в следующих статьях мы увидим, что вместе с сигнатурами модулей, объединения с одним вариантом помогают в сокрытии данных и безопасности на основе полномочий.
{{</footnote>}}

Представим, в качестве примера, что у вас есть идентификаторы заказчиков и идентификаторы заказов. И то
и другое — целые числа, так что мы можем их перепутать, а нам бы этого не хотелось.

Мы уже знаем, что подход с созданием псевдонима типа не работает, потому что псевдоним  — всего лишь
синоним, и он не создает отдельный тип. 
Вот как вы можете попытаться решить вопрос с помощью псевдонимов:

```fsharp
type CustomerId = int   // определяем псевдоним типа
type OrderId = int      // определяем другой псевдоним типа

let printOrderId (orderId:OrderId) =
   printfn "The orderId is %i" orderId

// пробуем
let custId = 1          // создаем идентификатор заказчика
printOrderId custId     // не получилось!
```

Даже если я явно указал, что параметр `orderId` имеет тип `OrderId`, я не могу гарантировать, что в функцию случайно не попадёт идентификатор заказчика.

А вот с помощью одиночного объединения мы легко обеспечиваем несовместимость типов. 

```fsharp
type CustomerId = CustomerId of int   // определяем тип объединения
type OrderId = OrderId of int         // определяем другой тип объединения

let printOrderId (OrderId orderId) =  // деконструируем в параметре
   printfn "The orderId is %i" orderId

//пробуем
let custId = CustomerId 1             // создаем идентификатор заказчика
printOrderId custId                   // Хорошо! Получаем ошибку компиляции.
```

Такой подход возможен и в C#, и Java, но используется он редко, потому что требует дополнительной работы по созданию и сопровождению классов для каждого типа.
А вот в F# для такого подхода не нужно писать много кода, так что он встречается часто.

Полезная подсказка про типы объединения с единственным вариантом — их можно сопоставлять со значением без использования полноценного выражения `match-with`.

```fsharp
// деконструируем в параметре
let printCustomerId (CustomerId customerIdInt) =
   printfn "The CustomerId is %i" customerIdInt

// или деконструируем явно через выражение let
let printCustomerId2 custId =
   let (CustomerId customerIdInt) = custId  // деконструируем здесь
   printfn "The CustomerId is %i" customerIdInt

// пробуем
let custId = CustomerId 1             // создаем идентификатор заказчика
printCustomerId custId
printCustomerId2 custId
```

Здесь основная «загвоздка» в том, что иногда образец надо заключать в скобки, иначе компилятор подумает, что вы определяете функцию!

```fsharp
let custId = CustomerId 1
let (CustomerId customerIdInt) = custId  // Корректное сопоставление с образцом
let CustomerId customerIdInt = custId    // Неверно! Новая функция?
```

Аналогично, если вам понадобится создать объединение с единственным пустым вариантом, в определении типа
надо будет поставить вертикальную черту, иначе компилятор подумает, что вы создаете псевдоним.

```fsharp
type TypeAlias = A     // псевдоним типа!
type SingleCase = | A   // тип объединения с единственным вариантом
```

## Сравнение объединений ##

Для типов объединений, также как и для других основных типы F#, компилятор автоматически создаёт функцию сравнения.
Два значения считаются равными, если у них один и тот же тип, один и тот же вариант, и значения для этого варианта у них равны.

```fsharp
type Contact = Email of string | Phone of int

let email1 = Email "bob@example.com"
let email2 = Email "bob@example.com"

let areEqual = (email1=email2)
```

## Представление объединений ##

У типов объединения приятное встроенное строковое представление, и они легко сериализуются.
Но, в отличие от кортежей, представление, полученное через ToString(), бесполезно*.

```fsharp
type Contact = Email of string | Phone of int
let email = Email "bob@example.com"
printfn "%A" email    // хорошо
printfn "%O" email    // отвратительно!
```

{{<footnote "*">}}
Примечание переводчика: похоже, с момента написания статьи что-то изменилось, так как сейчас оба случая выводятся одинаково «хорошо».
{{</footnote>}}
