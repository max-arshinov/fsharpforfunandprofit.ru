---
layout: post
title: "Использование функций в качестве строительных блоков"
description: "Композиция функций и мини-языки делают код более читаемым"
date: 2012-04-11
nav: why-use-fsharp
seriesId: "Зачем использовать F#?"
seriesOrder: 11
categories: [Conciseness, Functions]
---

Широко известен такой принцип хорошего дизайна, как определение набора базовых операций и последующее комбинирование этих строительных блоков различными путями для создания более сложных поведений.
В объектно-ориентированных языках эта цель порождает ряд подходов к реализации, таких как "флюент интерфейс"(англ. fluent interface, рус. "текучий интерфейс"), "паттерн стратегия", "паттерн декоратор", и т.д.
В F# для всех этих вещей используют один подход — композицию функций.

Давайте начнем с простого примера с использованием целых чисел.
Допустим, мы создали несколько базовых функций для выполнения арифметических действий:

```fsharp
// строительные блоки
let add2 x = x + 2
let mult3 x = x * 3
let square x = x * x

// тест
[1..10] |> List.map add2 |> printfn "%A"
[1..10] |> List.map mult3 |> printfn "%A"
[1..10] |> List.map square |> printfn "%A"
```

Теперь мы хотим создать новые функции, основанные на них:

```fsharp
// новые комбинированные функции
let add2ThenMult3 = add2 >> mult3
let mult3ThenSquare = mult3 >> square
```

Оператор "`>>`" - это оператор композиции.
Это значит: сначала выполни первую функцию, а потом вторую.

Обратите внимание как лаконичен этот способ комбинирования функций.
Нет никаких параметров, типов и другого неуместного шума.

Для уверенности, можно написать эти примеры менее лаконично и более явно:

```fsharp
let add2ThenMult3 x = mult3 (add2 x)
let mult3ThenSquare x = square (mult3 x)
```

Но этот более яный способ также более громоздкий:

* В явном стиле необходимо добавить параметр x и скобки, не смотря на то, что они не добавляют смысла коду.
* И в явном стиле функции написаны задом-наперед по отношению к порядку их применения. В моем примере функции `add2ThenMult3` я хочу сначала прибавить 2, а потом умножить. Синтаксис `add2 >> mult3` делает это визуально более очевидным, чем `mult3(add2 x)`.

Теперь давайте потестируем эти композиции:

```fsharp
// тест
add2ThenMult3 5
mult3ThenSquare 5
[1..10] |> List.map add2ThenMult3 |> printfn "%A"
[1..10] |> List.map mult3ThenSquare |> printfn "%A"
```

## Расширение существующих функций

Допустим мы хотим декорировать существующие функции логирующим поведением.
Мы можем также их комбинировать, чтобы создать новые функции, со встроенным логированием.

```fsharp
// вспомогательные функции;
let logMsg msg x = printf "%s%i" msg x; x     //без переноса строки
let logMsgN msg x = printfn "%s%i" msg x; x   //с переносом строки

// нвоые комбинированные функции с улучшенным логированием!
let mult3ThenSquareLogged =
   logMsg "before="
   >> mult3
   >> logMsg " after mult3="
   >> square
   >> logMsgN " result="

// тест
mult3ThenSquareLogged 5
[1..10] |> List.map mult3ThenSquareLogged //применить ко всему списку
```

У нашей новой функции `mult3ThenSquareLogged` ужасное имя, но её легко использовать и она неплохо прячет сложность функций вошедших в её состав.
Вы можете видеть, что если вы хорошо опишите свои функции - строительные блоки, то такая композиция может быть весьма мощным способом получения новой функциональности.

Но подождите, это еще не все!
В F# функции - это объекты первого класса, и ими можно манипулировать с помощью другого кода на F#.
Вот пример использования оператора композиции для схлопывания списка функций в одну операцию.

```fsharp
let listOfFunctions = [
   mult3;
   square;
   add2;
   logMsgN "result=";
   ]

// комбинируем все функции в списке в одну
let allFunctions = List.reduce (>>) listOfFunctions

//тест
allFunctions 5
```

## Мини языки

Предметно-ориентированные языки (англ. domain-specific language, DSL) широко известны в качестве техники создания более читаемого и лаконичного кода.
Функциональный подход отлично для этого подходит.

Если Вам необходимо, Вы можете пройти путем создания полностью "внешнего" предметно-ориентированного языка со своим лексером, парсером, и т.д., и существуют различные наборы инструментов для F#, которые сделают эту задачу достаточно простой.

Но во многих случаях проще придерживаться синтаксиса F#, и просто спроектировать набор "глаголов" и "существительных", инкапсулирующих нужное нам поведение.

Возможность лаконичного создания новых типов и дальнейшего сопоставления с ними значительно упрощает быстрое создание флюент интерфейсов.
Например вот небольшая функция, вычисляющая даты используя простой словарь.
Обратите внимание что два новых типа в стиле перечислений были определены исключительно для этой функции.

```fsharp
// задаем словарь
type DateScale = Hour | Hours | Day | Days | Week | Weeks
type DateDirection = Ago | Hence

// создаем функцию, сопоставляющую со словарем
let getDate interval scale direction =
    let absHours = match scale with
                   | Hour | Hours -> 1 * interval
                   | Day | Days -> 24 * interval
                   | Week | Weeks -> 24 * 7 * interval
    let signedHours = match direction with
                      | Ago -> -1 * absHours
                      | Hence ->  absHours
    System.DateTime.Now.AddHours(float signedHours)

// протестируем на нескольких примерах
let example1 = getDate 5 Days Ago
let example2 = getDate 1 Hour Hence

// эквивалент для C# будет выглядеть примерно так:
// getDate().Interval(5).Days().Ago()
// getDate().Interval(1).Hour().Hence()
```

В примере выше был только один "глагол", использующий несколько "существительных".

В следующих примерах демонстрируется как Вы могли бы построить функциональный эквивалент флюент интерфейса со многими "глаголами".

Допустим что мы создаем программу для рисования с различными фигурами.
У каждой фигуры есть цвет, размер, ярлык и действие, выполняемое по клику, и нам нужен флюент интерфейс для настройки каждой фигуры.

Вот пример того, как простая цепочка методов флюент интерфейса может выглядеть на C#:

```csharp
FluentShape.Default
   .SetColor("red")
   .SetLabel("box")
   .OnClick( s => Console.Write("clicked") );
```

Однако концепт "флюент интерфейса" и "цепочки методов" имеет смысл только для объектно ориентированного дизайна.
В функциональном языке как F# ближайшим эквивалентом будет использование конвейерного оператора для создания цепочки функций.

Давайте начнем с базового типа Shape:

```fsharp
// создать базовый тип
type FluentShape = {
    label : string;
    color : string;
    onClick : FluentShape->FluentShape // тип функции
    }
```

Добавим некоторые базовые функции:

```fsharp
let defaultShape =
    {label=""; color=""; onClick=fun shape->shape}

let click shape =
    shape.onClick shape

let display shape =
    printfn "My label=%s and my color=%s" shape.label shape.color
    shape   //возвращаем ту же фигуру
```

Для работы "цепочки вызовов", каждая функция должна возвращать объект, который можно будет использовать дальше по цепочке.
Так что Вы можете видеть, что функция "`display`" возвращает фигуру, вместо ничего.

Далее мы создадим несколько функций-помощников, которые мы представим как "мини-язык", и которые будут использованы пользователями языка как строительные блоки.

```fsharp
let setLabel label shape =
   {shape with FluentShape.label = label}

let setColor color shape =
   {shape with FluentShape.color = color}

//добавить действие по клику к тому, что уже там есть
let appendClickAction action shape =
   {shape with FluentShape.onClick = shape.onClick >> action}
```

Обратите внимание на то, что `appendClickAction` принимает функцию в качестве параметра и комбинирует её с существующим действием по клику.
По мере того, как Вы будете углубляться в функциональный подход к переиспользованию, Вы начнете замечать намного больше "функций высшего порядка" вроде этой, это функции которые совершают действия над другими функциями.
Комбинирование функций таким образом - это один из ключей к пониманию функционального подхода к программированию.

Теперь как пользователь этого "мини-языка", я могу скомбинировать базовые функции-помощники в свои более сложные функции, создавая свою собственную библиотеку функций.
(В C# это то, чего можно добиться с помощью методов расширений.)

```fsharp
// Скомбинировать две "базовые" функции для создания сложной функции
let setRedBox = setColor "red" >> setLabel "box"

// Создать новую функцию скомбинировав с предыдущей функцией
// Она переопределяет значение цвета, но не трогает ярлык.
let setBlueBox = setRedBox >> setColor "blue"

// Создание особого вида appendClickAction
let changeColorOnClick color = appendClickAction (setColor color)
```

Далее я могу скомбинировать эти функции вместе чтобы создать объекты с нужным поведением.

```fsharp
// подготовим несколько тестовых значений
let redBox = defaultShape |> setRedBox
let blueBox = defaultShape |> setBlueBox

// создадим фигуру, меняющую цвет по клику
redBox
    |> display
    |> changeColorOnClick "green"
    |> click
>   |> display  // new version after the click
    |> display  // новая версия после клика

// создадим фигуру, меняющую ярлык и цвет по клику
blueBox
    |> display
    |> appendClickAction (setLabel "box2" >> setColor "green")
    |> click
>   |> display  // new version after the click
    |> display  // новая версия после клика
```

Во втором случае я на самом деле передаю две функции в `appendClickAction`, но я сперва комбинирую их в одну.
Такие вещи очень просто делать с хорошо структурированной библиотекой функций, но это достаточно тяжело сделать в C# без использования лямбд внутри лямбд.

Вот более сложный пример.
Мы создадим функцию "`showRainbow`" которая, для каждого цвета радуги задаёт цвет и выводит фигуру.

```fsharp
let rainbow =
    ["red";"orange";"yellow";"green";"blue";"indigo";"violet"]

let showRainbow =
    let setColorAndDisplay color = setColor color >> display
    rainbow
    |> List.map setColorAndDisplay
    |> List.reduce (>>)

// тестируем функцию showRainbow
defaultShape |> showRainbow
```

Обратите внимание на то, что функции становятся более сложными, но количество кода все еще маленькое.
Одна из причин — это то, что параметры функций часто могут быть игнорированы во время комбинирования функций, что уменьшает визуальный беспорядок.
Например функция "`showRainbow`" принимает фигуру в качестве параметра, но это не показано явно!
Эта элизия параметров называется бесточечный стиль (бесточечная нотация, англ. "point-free" style) и будет обсуждаться далее в серии ["думай функционально"](/series/thinking-functionally.html).
